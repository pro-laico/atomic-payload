import fs from 'fs'
import path from 'path'
import https from 'https'
import dotenv from 'dotenv'
import { fileURLToPath } from 'url'
import { PayloadSDK } from '@payloadcms/sdk'
import { Font, GenericFontFamily, Config } from '@/ts/types'

const colors = {
  blue: (t: string) => `\x1b[34m${t}\x1b[0m`,
  green: (t: string) => `\x1b[32m${t}\x1b[0m`,
  red: (t: string) => `\x1b[31m${t}\x1b[0m`,
  orange: (t: string) => `\x1b[33m${t}\x1b[0m`,
}

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

dotenv.config({ path: path.join(__dirname, '../../../.env') })

const FONT_FILES_DIR = './public/fonts'
const FONT_DEFINITION_FILE = './src/app/definition.ts'

type FontExtensions = {
  sans: string
  serif: string
  mono: string
  display: string
}

let hasWarnings = false

function warn(message: string, error?: unknown) {
  hasWarnings = true
  console.warn(message)
  if (error) console.warn(error)
}

const requiredEnvVars = {
  LIVE_SITE_URL: process.env.LIVE_SITE_URL,
  BLOB_READ_WRITE_TOKEN: process.env.BLOB_READ_WRITE_TOKEN,
  SCRIPT_USER_EMAIL: process.env.SCRIPT_USER_EMAIL,
  SCRIPT_USER_PASSWORD: process.env.SCRIPT_USER_PASSWORD,
}

for (const [key, value] of Object.entries(requiredEnvVars)) {
  if (!value) warn(colors.red(`Missing required environment variable: ${key}`))
}

const sdk = new PayloadSDK<Config>({ baseURL: `${process.env.LIVE_SITE_URL}/api` })

function ensureFontOutputs() {
  if (!fs.existsSync(FONT_FILES_DIR)) fs.mkdirSync(FONT_FILES_DIR, { recursive: true })

  for (const file of fs.readdirSync(FONT_FILES_DIR)) fs.unlinkSync(path.join(FONT_FILES_DIR, file))

  // Always create a safe fallback definition file
  generateFontDefinitions({ sans: '', serif: '', mono: '', display: '' })
}

function generateFontDefinitions(extensions: FontExtensions): void {
  const configs: Array<{
    name: string
    type: GenericFontFamily
    extension: string
    variable: string
  }> = [
    { name: 'fontSans', type: 'sans', extension: extensions.sans, variable: '--font-setSans' },
    { name: 'fontSerif', type: 'serif', extension: extensions.serif, variable: '--font-setSerif' },
    { name: 'fontMono', type: 'mono', extension: extensions.mono, variable: '--font-setMono' },
    { name: 'fontDisplay', type: 'display', extension: extensions.display, variable: '--font-setDisplay' },
  ]

  const available = configs.filter((c) => c.extension)

  const declarations = available
    .map((c) => `const ${c.name} = localFont({ src: '../../public/fonts/${c.type}.${c.extension}', variable: '${c.variable}' })`)
    .join('\n')

  const exports = available.map((c) => c.name).join(', ')

  fs.writeFileSync(
    FONT_DEFINITION_FILE,
    `// DO NOT EDIT MANUALLY. THIS FILE IS AUTOMATICALLY GENERATED.
${declarations.length === 0 ? '//eslint-disable-next-line' : ''}
import localFont from 'next/font/local'

${declarations || '// No fonts available'}

const fonts = { ${exports} }
export default fonts
`,
  )
}

async function downloadFile(fileUrl: string, outputPath: string): Promise<void> {
  const file = fs.createWriteStream(outputPath)

  return new Promise((resolve, reject) => {
    https
      .get(fileUrl, (res) => {
        res.pipe(file)
        file.on('finish', () => {
          file.close((err) => {
            if (err) reject(err)
            else resolve()
          })
        })
      })
      .on('error', (err) => {
        if (fs.existsSync(outputPath)) fs.unlinkSync(outputPath)
        reject(err)
      })
  })
}

async function downloadFont(font: Font | string | null, fontType: keyof FontExtensions, baseUrl: string): Promise<string | undefined | void> {
  if (typeof font === 'string') return warn(colors.orange(`The ${fontType} font is a string reference`))
  if (!font?.filename) return warn(colors.orange(`No ${fontType} font found`))

  try {
    const extension = font.filename.split('.').pop()?.toLowerCase() || 'ttf'
    await downloadFile(`${baseUrl}/${font.filename}?download=1`, `${FONT_FILES_DIR}/${fontType}.${extension}`)
    console.log(`${colors.green('✓')} Downloaded ${fontType} font`)
    return extension
  } catch (err) {
    warn(colors.red(`Failed to download ${fontType} font`), err)
  }
}

async function run() {
  console.log(colors.blue('Starting Font Download...\n'))

  // Always ensure outputs exist so imports never break
  ensureFontOutputs()

  if (hasWarnings) {
    console.warn(colors.orange('Font download failed — No fonts will be used'))
    return
  }

  const blobToken = process.env.BLOB_READ_WRITE_TOKEN!
  const accountId = blobToken.split('_').slice(-2, -1)[0]
  const baseUrl = `https://${accountId}.public.blob.vercel-storage.com`

  let user
  try {
    user = await sdk.login({
      collection: 'users',
      data: {
        email: process.env.SCRIPT_USER_EMAIL!,
        password: process.env.SCRIPT_USER_PASSWORD!,
      },
    })
  } catch (err) {
    warn(colors.red('Authentication failed'), err)
    return
  }

  let designSet
  try {
    designSet = await sdk.find(
      { collection: 'designSet', where: { active: { equals: true } }, limit: 1 },
      { headers: { Authorization: `JWT ${user.token}` } },
    )
  } catch (err) {
    warn(colors.red('Failed to fetch design set'), err)
    return
  }

  if (!designSet.docs.length) return warn(colors.red('No active design set found'))

  const fonts = designSet.docs[0].font
  if (!fonts) return warn(colors.red('No font configuration found'))

  const hasProcessableFonts = Object.values(fonts).some((font) => typeof font === 'object' && font?.filename)
  if (!hasProcessableFonts) return console.log(colors.green('No valid fonts to process. Continuing build process.'))

  console.log(colors.green('✓ Font configuration found\n'))

  const extensions: FontExtensions = { sans: '', serif: '', mono: '', display: '' }
  const entries = Object.entries(fonts) as Array<[keyof FontExtensions, Font | string | null]>

  const results = await Promise.all(entries.map(([key, font]) => downloadFont(font, key, baseUrl)))

  entries.forEach(([key], i) => {
    extensions[key] = results[i] ?? ''
  })

  if (hasWarnings) {
    console.warn(colors.orange('\n⚠ Warnings encountered — No fonts will be used.'))
    return
  }

  generateFontDefinitions(extensions)
  console.log(colors.green('\n✓ Font definitions generated successfully\n'))
}

run().catch((err) => warn(colors.red('Unexpected script failure'), err))
